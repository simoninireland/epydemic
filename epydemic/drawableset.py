# A set that can be drawn from quickly
#
# Copyright (C) 2021 Simon Dobson
#
# This file is part of epydemic, epidemic network simulations in Python.
#
# epydemic is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# epydemic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with epydemic. If not, see <http://www.gnu.org/licenses/gpl.html>.

from epydemic import Element
from typing import Any, Set, List, Tuple, Iterable
import numpy


class Bitstream(object):
    '''An infinite stream of random bits. The bits are generated from a
    random number generated by the generator in `numpy` and consumed bitwise.

    :param size: (optional) size of the entropy pool in words'''

    # Singleton instance, created on demand
    _bitstream: 'Bitstream' = None             #: Default bit stream generator.

    @classmethod
    def default_rng(cl) -> 'Bitstream':
        '''Static method to return the default bitstream.

        @returns: the bitstream'''
        if cl._bitstream is None:
            cl._bitstream = Bitstream()
        return cl._bitstream

    # Underlying types
    Dtype = numpy.int64                        #: Type for elements of the entropy pool.
    DtypeSize = 63                             #: Bits per element (excluding sign bit).

    def __init__(self, size: int =100):
        self._rng = numpy.random.default_rng()

        self._pool: List[int] = []                      # entropy pool
        self._size = size                               # size of the pool
        self._max: int = 2 ** self.DtypeSize - 1        # maximum value of an entry in the pool
        self._element: int = 0                          # current element from the pool
        self._nelement: int = 0                         # index of current element
        self._index: int = 0                            # current bit within the element
        self._mask: int = 1                             # bit-mask

        self._refill()

    def _refill(self):
        '''Re-fill the entropy pool. This creates another batch of random numbers
        to be drawn from.'''
        self._pool = self._rng.integers(self._max, size=self._size, dtype=self.Dtype)
        self._nElement = 0
        self._element = int(self._pool[0])

    def __iter__(self) -> Iterable[int]:
        '''Return an iterator of bits.

        :retruns: an iterator'''
        return self

    def __next__(self) -> int:
        '''Return a random bit.

        :returns: a random bit'''
        bit = (self._element & self._mask) >> self._index
        self._index += 1
        self._mask <<= 1
        if self._index == self.DtypeSize:
            self._nElement += 1
            if self._nElement == self._size:
                self._refill()
            else:
                self._element = int(self._pool[self._nElement])
            self._index = 0
            self._mask = 1
        return bit

    def integer(self, n : int):
        '''Return a random integer. The integer is constructed using bits
        from the generator.

        :param n: the limit
        :returns: a random integer on the range [0, n]'''
        v = 0
        m = 1
        while True:
            m <<= 1
            if m >= n:
                return v
            else:
                v <<= 1
                v += next(self)


class TreeNode(object):
    '''A node in an AVL tree.

    :param d: the data at the tree node
    :param p: (optional) the parent node (defaults to None)

    '''

    def __init__(self, d: Element, p: 'TreeNode' = None):
        self._left: 'TreeNode' = None    # left sub-tree
        self._right: 'TreeNode' = None   # right sub-tree
        self._parent: 'TreeNode' = p     # parent nodes
        self._data: Element = d          # value at this node
        self._height: int = 0            # height of the tree

    def __len__(self) -> int:
        '''Return the size of the tree. This is intended for testing only,
        as it's a slow recursive count: :class:`DrawableSet` maintains
        its size itself.

        :returns: the size of the tree'''
        s = 1
        if self._left is not None:
            s += len(self._left)
        if self._right is not None:
            s += len(self._rignt)
        return s

    def add(self, e: Element) -> Tuple[bool, 'TreeNode']:
        '''Add an element to the tree.

        This method performs two tasks. It adds the element, testing
        whether it was in fact added or was a repetition; and it
        potentially replaces trhe overall tree root.

        :returns: a pair (wasadded, newroot)'''
        if e == self._data:
            return (False, None)
        elif e < self._data:
            if self._left is None:
                self._left = TreeNode(e, self)
                self._updateHeights()
                return (True, self._left._rebalance())
            else:
                return self._left.add(e)
        else:
            if self._right is None:
                self._right = TreeNode(e, self)
                self._updateHeights()
                return (True, self._right._rebalance())
            else:
                return self._right.add(e)

    def _updateHeights(self):
        '''Walk back to the root updating the heights of nodes.'''
        if self._updateHeight() and self._parent is not None:
            self._parent._updateHeights()

    def _updateHeight(self) -> bool:
        '''Update the node height.'''
        lh = self._left._height + 1 if self._left is not None else 0
        rh = self._right._height + 1 if self._right is not None else 0
        h = max(lh, rh)
        if h != self._height:
            self._height = h
            return True
        else:
            return False

    def isUnbalanced(self) -> bool:
        lh = self._left._height + 1 if self._left is not None else 0
        rh = self._right._height + 1 if self._right is not None else 0
        return abs(lh - rh) > 1

    def _findUnbalanced(self) -> 'TreeNode':
        '''Walk back up the tree looking for the shallowest unbalanced
        node.'''
        if self.isUnbalanced():
            return self
        elif self._parent is None:
            return None
        else:
            return self._parent._findUnbalanced()

    def _tallerSubtree(self) -> 'TreeNode':
        '''Return the taller of teh node's sub-trees.'''
        lh = self._left._height + 1 if self._left is not None else 0
        rh = self._right._height + 1 if self._right is not None else 0
        if lh > rh:
            return self._left
        else:
            return self._right

    def _rebalance(self, recursive: bool = False) -> 'TreeNode':
        '''Rebalance the tree after addition of a node.'''

        # find the shallowest unbalanced node
        z = self._findUnbalanced()
        if z is None:
            # tree is balanced all the way up
            return None
        else:
            root = z._rotate()

            if root._parent is None:
                return root
            elif recursive:
                # call again on the parent
                return root._parent._rebalance(True)
            else:
                return None

    def _rotate(self) -> 'TreeNode':
        z = self

        # find the two other nodes for the rotation
        y = z._tallerSubtree()
        x = y._tallerSubtree()

        # grab the parent to which we'll re-attach the new root
        # after rotation
        parent = z._parent

        # perform the appropriate rotation
        if z._data < y._data < x._data:
            root = y
            #print('a-b-c about ' + str(z._data))
            z._right = y._left
            if y._left is not None:
                y._left._parent = z
            y._left = z
            z._parent = y
            z._updateHeight()
            if z.isUnbalanced():
                z._rotate()
            y._updateHeight()
        elif x._data < y._data < z._data:
            root = y
            #print('c-b-a about ' + str(z._data))
            z._left = y._right
            if y._right is not None:
                y._right._parent = z
            y._left = x
            x._parent = y
            y._right = z
            z._parent = y
            z._updateHeight()
            if z.isUnbalanced():
                z._rotate()
            y._updateHeight()
        elif z._data < y._data and x._data < y._data:
            root = x
            #print('a-c-b about ' + str(z._data))
            y._left = x._right
            if x._right is not None:
                x._right._parent = y
            z._right = x._left
            if x._left is not None:
                x._left._parent = z
            x._left = z
            z._parent = x
            x._right = y
            y._parent = x
            z._updateHeight()
            y._updateHeight()
            if z.isUnbalanced():
                z._rotate()
            if y.isUnbalanced():
                y._rotate()
            x._updateHeight()
        else:
            root = x
            #print('c-a-b about ' + str(z._data))
            y._right = x._left
            if x._left is not None:
                x._left._parent = y
            z._left = x._right
            if x._right is not None:
                x._right._parent = z
            x._left = y
            y._parent = x
            x._right = z
            z._parent = x
            z._updateHeight()
            y._updateHeight()
            if z.isUnbalanced():
                z._rotate()
            if y.isUnbalanced():
                y._rotate()
            x._updateHeight()

        # re-parent the new root
        root._parent = parent
        if parent is not None:
            # glue new local root into the parent in place of z,
            # the old root
            if parent._left == z:
                parent._left = root
            else:
                parent._right = root

            # update the heights back up to the root
            parent._updateHeights()

        # return the new root of the rotated tree
        return root

    def find(self, e: Element) -> 'TreeNode':
        '''Search for an element in the tree, returning its node..

        :param e: the element
        :returns: the node holding the element or None'''
        if e == self._data:
            return self
        elif e < self._data:
            if self._left is None:
                return None
            else:
                return self._left.find(e)
        else:
            if self._right is None:
                return None
            else:
                return self._right.find(e)

    def inOrderTraverse(self) -> List[Element]:
        es = []
        if self._left is not None:
            es.extend(self._left.inOrderTraverse())
        es.append(self._data)
        if self._right is not None:
            es.extend(self._right.inOrderTraverse())
        return es

    def _leftmost(self) -> 'TreeNode':
        '''Return the leftmost node in a tree.'''
        if self._left is None:
            return self
        else:
            return self._left._leftmost()

    def _rightmost(self) -> 'TreeNode':
        '''Return the rightmost node in a tree.'''
        if self._right is None:
            return self
        else:
            return self._right._rightmost()

    def discard(self, e) -> Tuple[bool, bool, 'TreeNode']:
        '''Delete the given element from the tree, if it is present.

        This method performs three integrated tasks. If the element
        is present, it is removed; the resulting set is tested
        for emptiness; and any change to the overall root is detected.
        These three tasks each form an element of the return value.

        :returns: a triple (waspresent, nowempty, newroot)'''
        if e == self._data:
            # grab the parent node that will need to have
            # the replacement re-attached
            parent = self._parent

            # switch on the states of sub-trees
            if self._left is None:
                if self._right is None:
                    # leaf node, can be deleted immediately
                    #print('leaf')
                    if parent is None:
                        # we're the last node in the tree
                        return (True, True, None)
                    else:
                        # delete from parent
                        if parent._left == self:
                            #print('on left')
                            parent._left = None
                        else:
                            #print ('on right')
                            parent._right = None
                        parent._updateHeights()
                        return (True, False, parent._rebalance(True))
                else:
                    #print('right sub-tree only')
                    # only a right sub-tree, slide up to replace
                    if parent is None:
                        # we're the root, replace us
                        self._right._parent = None
                        return (True, False, self._right)
                    else:
                        # replace us with our sub-tree
                        if parent._left == self:
                            parent._left = self._right
                            self._right._parent = parent
                        else:
                            parent._right = self._right
                            self._right._parent = parent
                        parent._updateHeights()
                        return (True, False, parent._rebalance(True))
            elif self._right is None:
                #print('left sub-tree only')
                # only a left sub-tree, slide up to replace
                if self._parent is None:
                    # we're the root, replace us
                    self._left._parent = None
                    return (True, False, self._left)
                else:
                    # replace us with our sub-tree
                    if parent._left == self:
                        parent._left = self._left
                        self._left._parent = parent
                    else:
                        parent._right = self._left
                        self._left._parent = parent
                    parent._updateHeights()
                    return (True, False, parent._rebalance(True))
            else:
                #print('two sub-trees')
                # two sub-trees, choose the least disruptive element
                # from the taller as replacement
                if self._left._height > self._right._height:
                    r = self._left._rightmost()
                    #print('replace with ' + str(r._data))
                else:
                    r = self._right._leftmost()
                    #print('replace with ' + str(r._data))
                self._data = r._data
                return r.discard(r._data)

        elif e < self._data:
            if self._left is None:
                return (False, False, None)
            else:
                return self._left.discard(e)
        else:
            if self._right is None:
                return (False, False, None)
            else:
                return self._right.discard(e)

    def _draw(self) -> Element:
        '''Draw an element from the tree at random.

        This implementation isn't fair (yet).

        :returns: a random element, or none if the set is empty'''
        bs = Bitstream.default_rng()
        pathlength = bs.integer(self._height)
        n = self
        bits = iter(bs)
        for _ in range(pathlength):
            b = next(bits)
            if b == 0:
                n = n._left
            else:
                n = n._right
            if n is None:
                n = self
        return n._data

    def __repr__(self) -> str:
        d = str(self._data)
        ld = str(self._left._data) if self._left is not None else '_'
        rd = str(self._right._data) if self._right is not None else '_'
        buf = f'{d}: {ld} {rd}\n'
        if self._left is not None:
            buf += str(self._left)
        if self._right is not None:
            buf += str(self._right)
        return buf


class DrawableSet(object):
    '''A set that can be drawn from randomly.

    The implementation uses an balanced binary search tree. Addition,
    deletion, and containment testing are all :math:`O(\log n)`
    average time complexity, as is the :meth:`draw` method that
    selects a uniformly random element.

    We don't implement the whole of the standard set interface as we
    don't need it for the current application. Possibly we ought to,
    just to be future-proof.

    '''

    def __init__(self):
        self._root: TreeNode = None
        self._size: int = 0

    def add(self, e: Element):
        '''Add an element to the set. This is a no-op if the element is already
        in the set.

        :param e: the element to add'''
        if self._root is None:
            # we're the root, store here
            self._root = TreeNode(e)
            self._size = 1
        else:
            (added, r) = self._root.add(e)
            if added:
                self._size += 1
            if r is not None:
                # the tree was rotated about the root
                self._root = r

    def __contains__(self, e: Element) -> bool:
        '''Check whether the given element is a member of the set.

        :param e: the element
        :returns: True if the element is in the set'''
        if self._root is None:
            return False
        else:
            return self._root.find(e) is not None

    def empty(self) -> bool:
        '''Test if the set is empty.

        :returns: True if the set is empty'''
        return self._root is None

    def __len__(self) -> int:
        '''Return the size of the set.

        :returns: the size of the set'''
        return self._size

    def __iter__(self) -> Iterable[Element]:
        return iter(self.elements())

    def elements(self) ->List[Element]:
        if self._root is None:
            return []
        else:
            return self._root.inOrderTraverse()

    def discard(self, e: Element):
        '''Discard the given element from the set. If the element
        isn't in the set, this is a no-op: use :meth:`remove`
        to detect removal of non-elements.

        :param e: the element'''
        if self._root is not None:
            (present, empty, r) = self._root.discard(e)
            if present:
                self._size -= 1
            if empty:
                # tree has been emptied
                self._root = None
            elif r is not None:
                # the tree was rotated about the root
                self._root = r

    def remove(self, e: Element):
        '''Remove the given element from the set, raising
        an exception if it wasn't present: use :meth:`discard`
        to allow the removal of non-elements.

        :param e: the element'''
        if self._root is None:
            raise KeyError(e)
        else:
            (present, empty, r) = self._root.discard(e)
            if present:
                self._size -= 1
            else:
                raise KeyError(e)
            if empty:
                # tree has been emptied
                self._root = None
            elif r is not None:
                # the tree was rotated about the root
                self._root = r

    def draw(self) -> Element:
        '''Draw an element from the set at random.

        :returns: a random element, or none if the set is empty'''
        if self._root is None:
            return None
        else:
            return self._root._draw()
